# Neo Smart Contract Debugger Storage Schema

Version 3.3 of the Neo Smart Contract Debugger adds support for decoding the key/item byte streams
in contract storage into higher-order types. This makes it easier for developers to understand what
is happening inside their contracts.

You can see an example of how schematized storage looks in the debugger via this screenshot:

![Storage Schema Screenshot](images/StorageSchemaScreenshot.png)

This screenshot comes from the [Neo Contributor NFT sample](https://github.com/ngdenterprise/neo-contrib-token)
which has been updated to enable Storage Schema. In particular, note the following:

* Single value storages are displayed in the debugger as a simple variable name + value pair. 
  For example, notice that the `TotalSupply` storage contains a single integer value 3.
* Storage map storages are displayed in the debugger as a collection. Storage map storages have one
  or more key segments with name and type information that the debugger can display to the user.
  * For single segment keys, the segment value is used as the name of the variable. For example, 
    notice how the `Token` storage uses the token ID - a hex-encoded 256 bit hash code - as the
    variable name under the top level `Token` item.
  * For multi segment keys, the key/item pairs are displayed as a collection, with key and item
    children. The key item has a child for each segment in the key, displaying that segment's name
    and value. For example, notice how the `AccountToken` storage has three key/item pairs. The
    first key/item pair has been expanded to show the key segments - `owner` and `tokenId`.
* Storage items can be primitive values such as integers and hash codes. They can also be composite
  types such as structures, arrays and maps. For example, notice how the `Token` storage values are
  `TokenState` instances, with fields such as `Owner` and `Name`.
* Storage Schema includes a primitive `Address` type. For example, notice that the `ContractOwner`
  storage item is the Neo address of the account that deployed the contract.
* The Storage Schema type model is also available for runtime types. You get a similar rich
  inspection experience for both storage and runtime types.
* Storage Schema information is included in the [debugger info](https://github.com/devhawk/proposals/blob/devhawk/cd2l/nep-19.md)
  generated by the compiler. 

## Getting Started

To get the new Storage Schema experience, you need the pre-release versions of the Neo Smart Contract
Debugger and the Neo C# compiler. You also need to update your smart contract project to reference the
pre-release version of the Neo Smart Contract Framework.

> Note, at this time only pre-release Neo C# compiler has been updated to generate the debug information
  needed for the Storage Schema experience. Other Neo compilers - including the current production
  release version of the Neo C# compiler - do not support the new experience yet. The debugger team
  is reaching out to help the other Neo compiler teams update their tools to support the new format. The
  goal is for all Neo developers - regardless of their language of choice - to get the full Storage
  Schema experience. It's just going to take time to update all the various tools.

If you want to try out the new experience before writing any code, the 
[`neo-contrib-token` NFT sample](https://github.com/ngdenterprise/neo-contrib-token) has been updated
to support the Storage Schema preview. To test drive the Storage Schema experience with the
NFT sample:

* Install Neo Smart Contract Debugger Pre-Release Extension (described below)
* Clone the [`neo-contrib-token` repo](https://github.com/ngdenterprise/neo-contrib-token)
* Open the repo in VSCode
* Check out the [`storage-schema-preview` branch](https://github.com/ngdenterprise/neo-contrib-token/tree/storage-schema-preview)
* Run the `reset neo express` build task. This task will install the right tools,
  compile the contracts in the repo and create the Neo-Express checkpoints needed
  for the debug launch configurations. Build tasks can be accessed via the VSCode
  `Terminal` menu.
* Switch to the Run and Debug view, select `mint (succeed)` launch configuration and Start Debugging

### Install Neo Smart Contract Debugger Pre-Release Extension

To install the debugger preview - even if you already have the debugger installed - visit the Neo Smart
Contract Debugger page in the 
[VSCode Marketplace](https://marketplace.visualstudio.com/items?itemName=ngd-seattle.neo-contract-debug)
Press the install button to launch the debugger extension management UI inside VSCode.

If you already have the debugger installed, there will be a button labeled "Switch to Pre-Release Version".
If you do not already have the debugger installed, there will be a button labeled "Install" with a
drop down menu that you can use to select the pre-release version for install. During the Storage Schema
preview, only the pre-release version of the debugger supports the new experience. Once installed, the
pre-release extension will update automatically as new pre-releases are published on the marketplace.
At any time, you can switch back to the release version of the debugger extension but navigating to the 
debugger extension management UI inside VSCode and pushing the "Switch to Release Version" button

> Note, the pre-release version of the debugger still supports the older debug information format. Even
  if you don't update your Neo C# compiler to generate the new debug information format, the debugger
  will still work (albeit with the older non-schematized view of contract storage).

As of v3.2, production releases of the debugger have even numbered minor version numbers while pre-releases
have odd minor version numbers. v3.3 of the Neo Smart Contract Debugger includes Storage Schema support.

### Install Storage Schema Neo C# Preview Compiler 

> Note, while the preview debugger will work with older debug information generated by the release
  Neo C# compiler and other Neo contract compilers, the preview compiler is **NOT COMPATIBLE** with
  the release debugger. If you want your project to work with the release debugger, you **MUST** use
  the release version of the compiler.

The Neo C# compiler is distributed as a [.NET tool](https://docs.microsoft.com/en-us/dotnet/core/tools/global-tools).
.NET tools are distributed as NuGet packages, typically downloaded from [nuget.org](http://nuget.org).
However, the Storage Schema preview version of the compiler (and framework, described below) are **NOT**
published on the central nuget.org repository. We have chosen to create a private NuGet repository to
host Storage Schema preview packages. This section describes how to configure your contract project
to work with the private package repository.

#### nuget.config File

NuGet must be configured to use the private package repository. This is done via a 
[`nuget.config` file](https://docs.microsoft.com/en-us/nuget/reference/nuget-config-file)
in your contract project root folder. Here are the contents of the NFT sample's nuget.config file:

``` xml
<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <packageSources>
    <add key="ngd-ent-nuget" value="https://ngdentnuget.blob.core.windows.net/packages/index.json" />
  </packageSources>
</configuration>
```

This file basically tells NuGet tools to look in the `ngd-ent-nuget` package repository if it can't
find a given package in the global nuget.org repository. 

#### Installing the Preview Neo C# Compiler 

.NET tools like the Neo C# compiler can be installed globally on a machine or locally to a project
folder. Since the Storage Schema enabled compiler is a preview release, we recommend installing
the compiler as a local tool. The NFT sample installs the preview compiler as a local tool.

> Note, this preview is in active development. New versions of the compiler and framework are expected
  to ship regularly. .NET tools have no built-in mechanism to auto update, so developers should
  regularly re-run the commands below to ensure their tools are up to date.

.NET tools are installed from the command line. Open a terminal window and navigate to the root folder
of your project. Note, this folder must have the `nuget.config` file described above. 

To install the compiler as a local tool, your project folder needs to have a tool manifest file. If
your project doesn't already have one, you can create a tool manifest via the `dotnet new tool-manifest`
command. To install or update the preview compiler, run this command:

``` shell
> dotnet tool update Neo.Compiler.CSharp --prerelease
```

To install the compiler as a global tool run the following command from the folder where you created
the `nuget.config` as described above. This command will ensure you have the latest version, including
prerelease versions downloaded from the private nuget repository referenced in the nuget.config file

``` shell
> dotnet tool update --global Neo.Compiler.csharp --prerelease
```

Regardless if the preview compiler is installed as global or local tool, the version installed should
include the prerelease tag `storage-schema-preview`. To distinguish the Storage Schema Preview versions
from production releases, the preview compiler and framework NuGet packages have a patch version number
over 1000 and the prerelease tag `storage-schema-preview`. For example, the initial Storage Schema preview
release version of the compiler and framework is `3.1.1035-storage-schema-preview`. 

If the dotnet tool update command reports an installed version that doesn't have the `storage-schema-preview`
tag, you will not get the Storage Schema Experience. If this happens, your `nuget.config` file is likely
invalid or missing.

### Using the Neo SmartContract Framework Preview Package

Like the Neo C# compiler, Storage Schema uses an updated SmartContract Framework that's available as a
preview from the private NuGet repository described above. The version of the SmartContract Framework
referenced in your project should match the version of the Neo C# Compiler you have installed.

The preview version of the SmartContract Framework can be added to an existing C# project via the 
`dotnet add package` command. The `add package` command must be run from the command line while
in the folder containing the `.csproj` file of your contract. Like the compiler installation, 
installing the preview version from the private NuGet repository requires the `nuget.config`
file be configured as described above.

``` shell
> dotnet add package neo.smartcontract.framework --prerelease
```

> Note, like .NET tools, package references are not updated automatically. You can use the 
  [`dotnet outdated` tool](https://github.com/dotnet-outdated/dotnet-outdated) or 
  [VersionLens extension](https://marketplace.visualstudio.com/items?itemName=pflannery.vscode-versionlens)
  to ensure your package versions are up to date.

### Storage Schema Preview Attributes

> Note, the attributes described in this section should be considered a first draft design. More information
  about the conceptual storage model that informed this design is [available below](#neo-contract-storage-conceptual-model).
  Other designs that are better integrated with contract storage imperative code or that leverage compile-time
  source generation will be considered before final release of the Storage Schema feature. If you have any
  feedback or suggestions regarding this design, please feel free to let us know by opening issues in the 
  [debugger GitHub repo](https://github.com/neo-project/neo-debugger/issues).

Once you install the preview debugger and C# compiler and the Smart Contract Framework package reference
has been updated to the latest version, you should be able to get the new rich Storage Schema experience
for runtime items (arguments, local variables and static variables) by simply recompiling your code with
the preview compiler. Getting the rich Storage Schema experience for storage keys and values requires 
adding a few attributes to your contract code. 

These new attributes have *NO EFFECT* on the execution of your contract code. They are only used by the 
preview C# compiler to generate the information needed to decode storage keys and values in the debugger.
If the these attributes are missing or incorrect, it will only affect the developers experience using the 
Variables view in the debugger. Even when storage schema information is available, the debugger always
provides a raw view of the storage keys and items that can be inspected the same way as previous versions
of the debugger.

The Smart Contract Framework preview includes two new attributes used to generate Storage Schema information:
`StorageGroup` and `StorageKeySegment`. Here is an 
[example](https://github.com/ngdenterprise/neo-contrib-token/blob/storage-schema-preview/token-contract/NeoContributorToken.cs#L33-L53)
of their use from the NFT sample:

``` cs
[StorageGroup(typeof(BigInteger))]
const byte Prefix_TotalSupply = 0x00;

[StorageGroup("Balances", typeof(BigInteger))]
[StorageKeySegment("owner", StorageKeySegmentType.Address)]
const byte Prefix_Balance = 0x01;

[StorageGroup(typeof(BigInteger))]
const byte Prefix_TokenId = 0x02;

[StorageGroup("Tokens", typeof(TokenState))]
[StorageKeySegment("tokenId", StorageKeySegmentType.Hash256)]
const byte Prefix_Token = 0x03;

[StorageGroup(typeof(int))]
[StorageKeySegment("owner", StorageKeySegmentType.Address)]
[StorageKeySegment("tokenId", StorageKeySegmentType.Hash256)]
const byte Prefix_AccountToken = 0x04;

[StorageGroup(typeof(UInt160))]
const byte Prefix_ContractOwner = 0xFF;
```

#### StorageGroup Attribute

The `StorageGroup` attribute must be attached to a const prefix value defined in the `SmartContract` class
(i.e. the class that derives from `SmartContract`). The `StorageGroup` attribute specifies the type of
the storage group's value. It also optionally provides the name of the storage group. If the name is
not specified in the attribute, the name of the const field is used. If the const fields starts with
`Prefix_` as the sample code fields above do, only the name of the field after `Prefix_` is used. So
the storage group created from the `Prefix_ContractOwner` field would be named `ContractOwner`.

The const field that a `StorageGroup` attribute is attached to must be a single byte or a string. The
value of the const field is used as the prefix value in storage. If the const field is a string,
the UTF8 encoding of the string is used as the storage group prefix;

> Note, C# has no mechanism for declaring a const collection of bytes except for strings. While the 
  underlying Storage Schema model allows for arbitrary multi-byte prefixes, there is currently no
  mechanism for declaring one via the `StorageGroup` attribute.

#### StorageKeySegment Attribute

Some storage groups only store a single value. For example, the NFT token sample above only has a single
Total Supply value and a single Contract Owner. However, most storage groups store multiple records of
related information, such as account balances or token information. To support multiple records in a given
group, each record must have a unique key value after the constant prefix. The `StorageKeySegment` attribute
declares the structure of key. 

Like the StorageGroup attribute, the `StorageKeySegment` attribute must be applied to a const field in
the `SmartContract` class. Additionally, there must also be `StorageGroup` attribute applied to the field,
otherwise the StorageKeySegment attribute is ignored.

Each storage key segment has a name and a type. Unlike `StorageGroup` value types, key segments must be
a primitive type as specified in the StorageKeySegmentType enumeration. Multiple `StorageKeySegment` attributes
may be applied to a single const field. To enable proper key decoding, the order of `StorageKeySegment`
attributes must match the order of key segments in the code.

All key segments except the last one must be fixed size in order to be decoded. The final (or single)
key segment can be of variable length (ByteArray and Integer).

These are the allowed storage key segment types. With the exception of `Address`, they all match values
from the [`ContractParameterType` enumeration](https://github.com/neo-project/neo/blob/master/src/neo/SmartContract/ContractParameterType.cs)
from the core Neo platform. `Address` is an alias for `Hash160`. The only difference is how they are
displayed in the debugger. `Hash160` values are displayed as hex encoded byte arrays while `Address`
values are displayed as standard Neo N3 addresses. The 
[Primitive Type section](https://github.com/neo-project/neo-debugger/blob/master/docs/storage-schema-overview.md#primitive-type)
below has more details on how the debugger handles address encoding.

* Boolean
* Integer
* ByteArray
* String
* Hash160
* Hash256
* PublicKey
* Signature
* Address

> Note, a future version of the Neo SmartContract Framework Preview will include a mechanism to
  declare type fields as `Address` as well. `Address` type fields will be displayed as Neo N3
  addresses like `Address` key segments are. 

## Neo Contract Storage Conceptual Model

In order to understand how Storage Schema works, it is useful to understand the underlying
model of Neo contract storage. If you are an experienced Neo contract developer, you may wish to
skim or skip this section.

Neo contract storage is a key/value byte array store. Each key and value is stored as a raw array
of bytes. Any additional structure of the key or value is provided by code and is unavailable via
the storage engine.

Neo contracts typically use hard coded key prefixes to group different types of data together.
Multi-byte prefixes are also supported, but are typically only needed for contacts with more than
255 prefixes. Otherwise multi-byte prefixes are just extra storage (and associated GAS cost) with
little additional value.

> Note, there are a variety of Neo N3 samples that use strings for storage prefixes. Such samples
  should not be considered best practice. Minimizing prefix length is considered the best practice
  for Neo contract storage.

As an example, the Neo Contributor NFT sample stores six different groups of data, each with its own
[unique single byte prefix](https://github.com/ngdenterprise/neo-contrib-token/blob/main/token-contract/NeoContributorToken.cs#L32). 

``` cs
const byte Prefix_TotalSupply = 0x00;
const byte Prefix_Balance = 0x01;
const byte Prefix_TokenId = 0x02;
const byte Prefix_Token = 0x03;
const byte Prefix_AccountToken = 0x04;
const byte Prefix_ContractOwner = 0xFF;
```

Some groups of data are only a single storage value. As an example, in the NFT sample there is a
single `TotalSupply` and `ContractOwner` value. In those cases the prefix is used directly as the
storage key. You can see this in the NFT Sample `UpdateTotalSupply` method where `Prefix_TotalSupply`
is used to construct the key used to read and write a single integer value. 

``` cs
StorageContext context = Storage.CurrentContext;
byte[] key = new byte[] { Prefix_TotalSupply };

BigInteger totalSupply = (BigInteger)Storage.Get(context, key);
Storage.Put(context, key, totalSupply + 1);
```

Of course, contracts often need to store multiple pieces of data in a single group. In these cases
each data item has its own unique key. The data item's key is pre-pended with the associated hard
coded prefix in order to group all related data together in storage. The pre-pended prefix also serves
to avoid key collisions, since the the key prefix is unique to the group. Neo contract languages
typically include helper classes to make it easy to manage multiple key/value pairs within a single
prefixed group. For example, the C# Smart Contract Framework provides the `StorageMap` to simplify the
management of related data under a common key prefix.

As an example, the NFT sample stores information about multiple minted NFTs. Each NFT has a unique
256 bit hash used as the token ID. Each token has additional information (such as owner and name)
stored in contract storage, keyed by the token ID. The hard coded `Prefix_Token` byte is used to 
group all token key/values together and a `StorageMap` is used to read and write NFT information.

``` cs
StorageMap tokenMap = new StorageMap(Storage.CurrentContext, Prefix_Token);
var tokenData = tokenMap.Get(tokenId); // tokenId provided as method parameter 
TokenState token = (TokenState)StdLib.Deserialize(tokenData);
token.Owner = newOwner; // newOwner provided as method parameter 
tokenMap.Put(tokenId, StdLib.Serialize(token));
```

`StorageMap`'s Get and Put methods automatically pre-pend the prefix provided to the constructor
when reading and writing to contract storage. This makes it easy for developers to be consistent
in their use of storage prefixes.

> Note, `StorageMap` also supports indexer syntax (i.e. `tokenMap[tokenId]`) for reading and
  writing to contract storage. Many sample contacts uses this syntax rather than Get/Put.

Storage keys may also be generated from multiple individual values. As an example, the `AccountToken`
prefix in the NFT sample is used to index all the tokens owned by a given address. For this
storage group, the item key is the owner address + the token ID. The StorageMap then pre-pends
the group prefix as it does for single key items as shown above.

``` cs
StorageMap accountMap = new(Storage.CurrentContext, Prefix_AccountToken);
// combine the owner and the token ID to generate the un-prefixed key
ByteString key = owner + tokenId;
accountMap.Put(key, 0);
```

By structuring the `AccountToken` key this way, the `StorageMap` can return a list of token IDs
owned by a single address using just a couple lines of code:

``` cs
StorageMap accountMap = new StorageMap(Storage.CurrentContext, Prefix_AccountToken);
return accountMap.Find(owner, FindOptions.KeysOnly | FindOptions.RemovePrefix);
```

The `StorageMap` here is constructed just as it was for the token owner update code above.
However, instead of using the `Get` method, this sample code uses the `Find` method, returning 
a list of all the key/value pairs starting with prefix (specified via constructor parameter) and
owner (specified via method parameter). The list returned by Find is further refined by specifying
the `KeysOnly` and `RemovePrefix` options. Note, Find removes the entire prefix it used for the 
search (i.e. `Prefix_AccountToken` and `owner` in this case)

### Unified Neo Contract Type Model

As stated above, Storage Schema objects reference information about Contract Types. Contract Types
is a new richer model for describing type information than has been used in the debugger previously.
This section describes this model (along with providing a road map for upcoming improvements).

> Note, the Contract Type Model only describe information about NeoVM and storage items in order to 
  provide a better debugger experience. This model does not modify the behavior of NeoVM or how
  contract storage works in any way.

Neo compilers generate debug info that is used by the debugger. This primarily consists of information
that the NeoVM doesn't need when executing contracts. For example, the NeoVM does not need to know
the names of method parameters and variables. However, it's easier for the developer if the debugger
can automatically map NeoVM stack items back to the associated variables defined by the developer.
The debug information generated by the compiler enables this mapping.

Debug info also contains information about a variable's type. This can be used in cases to modify how
a given variable is displayed in the debugger. For example, a string variable is stored as an
immutable byte array by NeoVM. By including variable type information in the debug info, the debugger
can convert the underling NeoVM stack item into a display format more closely aligned to the code written
by the developer. For example, the immutable byte array stored by NeoVM can be converted to a string
value by the debugger.

Unfortunately, the original type model used by the debugger today was not rich enough to capture the
details needed to provide the schematized storage view shown in the screen shot above. As such, a new 
richer model for contract type information was developed. Eventually, this new contract type model will
also be used to provide richer type information for runtime items in addition to storage items.

> Note: C# declarations for the new Contract Type Model are available in the 
  [Blockchain Toolkit Library project](https://github.com/ngdenterprise/neo-blockchaintoolkit-library/blob/master/src/bctklib/models/ContractTypes.cs)

#### Primitive Type

NeoVM supports three primitive types: booleans, arbitrary sized integers and immutable byte arrays.
While booleans and integers instances have clear debugger representations, byte arrays often
represent some type of higher level type, such as a 256 bit hash, a Neo address or a string.

The Contract Type model defines the following primitive types. These types can be directly represented
as byte arrays and thus can be stored in contract storage directly without serialization

* Boolean
* Integer
* ByteArray
* String
* Hash160
* Hash256
* PublicKey
* Signature
* Address

Most of these types should be familiar to Neo contract developers. Many of these primitive types overlap
with [ContractParameterType](https://github.com/neo-project/neo/blob/master/src/neo/SmartContract/ContractParameterType.cs)
values.

One primitive type to note is the `Address` type. Under the hood, `Address` is a 160 bit hash code, just as 
`Hash160` is. However, `Address` is rendered in the debugger UI using the standard Neo address encoding, leading
to values such as `NaTtKdE8nt1E9FKKhH6hScXmDGPjgjpdhi` instead of hex encoded byte arrays. Given the prevalence
of Neo addresses in contract code, it made sense to include a specific primitive type to represent addresses and
for them to render in the most developer friendly manner possible.

One other thing to note about `Address`: Some contracts use an all-zero 160 bit hash code to represent "no
address". As an example, the NFT sample uses the all-zero address to represent an NFT without at owner. Since
the all-zero address value typically has special meaning, the debugger displays the all-zero address value in
a special way to make it easy to identify. You can see an example of this in the `TokenState.Owner` value in
the screen shot from the start of this document. The `Erik Zhang` token has `N000000000000000000000000000000000`
for the owner value. Neo addresses are base58 encoded and zero (i.e. `0`) is not a valid address character. So
by encoding what is typically an invalid address this way, it is easy to identify without risk of colliding with
a valid Neo address.

When string encoding a primitive type, the name of the primitive type is used directly. If there is a conflict
with a user defined struct name, a '#' character can be used as a prefix to disambiguate. For example, `Address`
could be a struct type defined by a contract, but `#Address` always indicates the primitive address type. If there
is no name collision, the hash character is optional. 

#### Struct Type

As described in the StructDef section above, a struct is a named heterogeneous collection of fields. Field types
may be of any type described in this type model. In order to avoid collisions with other types, struct names 
may not contain characters (to avoid collisions with primitive types) or angle brackets (to avoid collisions
with Array and Map types below).

Structs are string encoded simply by their name. As an example, see the StorageDef example above where the 
`Token` storage value type is the `TokenState` StructDef.

#### Array&lt;T> Type

> Note, while Array&lt;T> types can be specified in Storage Schema files, they are currently not handled by
  the debugger and will be displayed as if they have Unspecified type. Display of Array&lt;T>  types will
  be implemented in a future version of the debugger.

An Array&lt;T> is a homogeneous collection of items. While the underlying NeoVM Array stack type is heterogenous,
it is common for developers to consistently store a given type in a given array. The C# Smart Contract
Framework even provides a generic List&lt;T> type for homogeneous collections.

When string encoding an Array type, the type of the homogeneous collection is specified between the brackets.
The value between the brackets can be any type of Contract Type, including primitives, unspecified, structs or
even other generic array and map types.

#### Map<K,V> Type

> Note, while `Map<K,V>` types can be specified in Storage Schema files, they are currently not handled by
  the debugger and will be displayed as if they have Unspecified type. Display of `Map<K,V>` types will
  be implemented in a future version of the debugger

A Map<K, V> is a dictionary that maps a key of type K to a value of type V. This is very similar conceptually
to how contact storage works. However, please note that contract storage and Maps are fundamentally different.
A StorageDef cannot be described as a Map<K, V>. A Map<K, V> can be serialized into contract storage, but the
Map keys cannot be iterated or inspected while stored as contract storage keys can.

When string encoding a map type, the key and value types of the map are stored between the brackets and separated
by a comma. The key type of a Map<K,V> *MUST* be a primitive type. The value type can be any type of Contract type
including primitives, unspecified, structs or even other generic array and map types.

#### Interop Type

NeoVM uses a special `InteropInterface` type to integrate contract and platform code. An `InteropInterface` 
stack item wraps a .NET object such as a storage context or an iterator. The runtime `InteropInterface` item
does not provide any interrogation mechanism - you can retrieve the wrapped .NET object if you already know
its type. However, the compiler knows the type of the wrapped objects type at compile time and includes the
wrapped type information in the contract's debug info.

Note, while the compiler can determine the type of an `InteropInterface`, they are still otherwise opaque to
the debugger. The debugger does not access the wrapped .NET object or any of its fields at runtime. 

#### Unspecified Type

There are times where type information is unspecified or cannot be calculated. For those case, the `Unspecified`
type can be used. Like primitive types, the Unspecified type is simply the string `Unspecified` with an optional
hash character prefix to handle potential name collisions.

The debugger does a small amount of type validation when displaying storage and stack items. For example, if a
given item has an associated Struct type, the debugger will validate the underlying NeoVM item is an array object
(array and structs are stored the same in NeoVM) and that the struct field count matches the array count. If
there is a mismatch, the debugger will discard the type information and display the value as if the type 
were Unspecified. 
